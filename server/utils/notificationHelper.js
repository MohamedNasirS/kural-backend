import Notification from "../models/Notification.js";

/**
 * Notification Helper Utility
 * Provides functions to auto-generate notifications for various events
 */

/**
 * Create notification(s) when a survey is created
 * @param {Object} survey - The created survey document
 * @param {Object} creator - The user who created the survey
 */
export async function onSurveyCreated(survey, creator) {
  try {
    const notifications = [];
    const assignedACs = survey.assignedACs || [];

    // Determine creator info
    const createdBy = {
      userId: creator._id || creator.id,
      role: creator.role || "SYSTEM",
      name: creator.name || creator.email || "System",
    };

    if (assignedACs.length === 0) {
      // GLOBAL notification - no specific ACs assigned means all ACs
      notifications.push({
        createdBy,
        scope: "GLOBAL",
        aci_id: null,
        type: "SURVEY_CREATED",
        title: "New Survey Available",
        message: `Please complete the survey: ${survey.title}`,
        priority: "normal",
        relatedEntity: {
          type: "SURVEY",
          id: survey._id || survey.id,
        },
        validFrom: new Date(),
        validTill: null,
        isAutoGenerated: true,
      });
    } else {
      // Create one notification per AC
      for (const acId of assignedACs) {
        notifications.push({
          createdBy,
          scope: "ACI",
          aci_id: acId,
          type: "SURVEY_CREATED",
          title: "New Survey Available",
          message: `Please complete the survey: ${survey.title}`,
          priority: "normal",
          relatedEntity: {
            type: "SURVEY",
            id: survey._id || survey.id,
          },
          validFrom: new Date(),
          validTill: null,
          isAutoGenerated: true,
        });
      }
    }

    if (notifications.length > 0) {
      await Notification.insertMany(notifications);
      console.log(`[Notification] Created ${notifications.length} notification(s) for survey: ${survey.title}`);
    }

    return notifications;
  } catch (error) {
    console.error("[Notification] Error creating survey notifications:", error);
    // Don't throw - notifications should not block survey creation
    return [];
  }
}

/**
 * Create notification(s) when a survey is updated
 * @param {Object} survey - The updated survey document
 * @param {Object} updater - The user who updated the survey
 */
export async function onSurveyUpdated(survey, updater) {
  try {
    const notifications = [];
    const assignedACs = survey.assignedACs || [];

    // Determine updater info
    const createdBy = {
      userId: updater._id || updater.id,
      role: updater.role || "SYSTEM",
      name: updater.name || updater.email || "System",
    };

    if (assignedACs.length === 0) {
      // GLOBAL notification
      notifications.push({
        createdBy,
        scope: "GLOBAL",
        aci_id: null,
        type: "SURVEY_UPDATED",
        title: "Survey Updated",
        message: `The survey "${survey.title}" has been updated. Please review.`,
        priority: "normal",
        relatedEntity: {
          type: "SURVEY",
          id: survey._id || survey.id,
        },
        validFrom: new Date(),
        validTill: null,
        isAutoGenerated: true,
      });
    } else {
      // Create one notification per AC
      for (const acId of assignedACs) {
        notifications.push({
          createdBy,
          scope: "ACI",
          aci_id: acId,
          type: "SURVEY_UPDATED",
          title: "Survey Updated",
          message: `The survey "${survey.title}" has been updated. Please review.`,
          priority: "normal",
          relatedEntity: {
            type: "SURVEY",
            id: survey._id || survey.id,
          },
          validFrom: new Date(),
          validTill: null,
          isAutoGenerated: true,
        });
      }
    }

    if (notifications.length > 0) {
      await Notification.insertMany(notifications);
      console.log(`[Notification] Created ${notifications.length} notification(s) for survey update: ${survey.title}`);
    }

    return notifications;
  } catch (error) {
    console.error("[Notification] Error creating survey update notifications:", error);
    return [];
  }
}

/**
 * Create notification(s) when master data is updated
 * @param {Object} section - The updated master data section document
 * @param {Object} updater - The user who updated the master data
 */
export async function onMasterDataUpdated(section, updater) {
  try {
    const notifications = [];
    const aciIds = section.aci_id || [];

    // Determine updater info
    const createdBy = {
      userId: updater._id || updater.id,
      role: updater.role || "SYSTEM",
      name: updater.name || updater.email || "System",
    };

    if (aciIds.length === 0) {
      // GLOBAL notification - no specific ACs means all ACs
      notifications.push({
        createdBy,
        scope: "GLOBAL",
        aci_id: null,
        type: "MASTER_DATA_UPDATED",
        title: "Master Data Updated",
        message: `The master data "${section.name}" has been updated.`,
        priority: "normal",
        relatedEntity: {
          type: "MASTER_DATA",
          id: section._id || section.id,
        },
        validFrom: new Date(),
        validTill: null,
        isAutoGenerated: true,
      });
    } else {
      // Create one notification per AC
      for (const acId of aciIds) {
        notifications.push({
          createdBy,
          scope: "ACI",
          aci_id: acId,
          type: "MASTER_DATA_UPDATED",
          title: "Master Data Updated",
          message: `The master data "${section.name}" has been updated.`,
          priority: "normal",
          relatedEntity: {
            type: "MASTER_DATA",
            id: section._id || section.id,
          },
          validFrom: new Date(),
          validTill: null,
          isAutoGenerated: true,
        });
      }
    }

    if (notifications.length > 0) {
      await Notification.insertMany(notifications);
      console.log(`[Notification] Created ${notifications.length} notification(s) for master data update: ${section.name}`);
    }

    return notifications;
  } catch (error) {
    console.error("[Notification] Error creating master data notifications:", error);
    return [];
  }
}

/**
 * Create a manual notification (for admin use)
 * @param {Object} data - Notification data
 * @param {Object} creator - The user creating the notification
 */
export async function createManualNotification(data, creator) {
  try {
    const notification = await Notification.create({
      createdBy: {
        userId: creator._id || creator.id,
        role: creator.role,
        name: creator.name || creator.email || "Admin",
      },
      scope: data.scope,
      aci_id: data.scope === "ACI" ? data.aci_id : null,
      type: data.type,
      title: data.title,
      message: data.message,
      priority: data.priority || "normal",
      validFrom: data.validFrom || new Date(),
      validTill: data.validTill || null,
      isAutoGenerated: false,
    });

    console.log(`[Notification] Created manual notification: ${notification.title}`);
    return notification;
  } catch (error) {
    console.error("[Notification] Error creating manual notification:", error);
    throw error;
  }
}

/**
 * Delete notifications related to a specific entity
 * @param {String} entityType - Type of entity ("SURVEY" | "MASTER_DATA")
 * @param {ObjectId} entityId - ID of the entity
 */
export async function deleteRelatedNotifications(entityType, entityId) {
  try {
    const result = await Notification.updateMany(
      {
        "relatedEntity.type": entityType,
        "relatedEntity.id": entityId,
      },
      {
        deleted: true,
      }
    );

    console.log(`[Notification] Soft-deleted ${result.modifiedCount} notifications for ${entityType}: ${entityId}`);
    return result;
  } catch (error) {
    console.error("[Notification] Error deleting related notifications:", error);
    return { modifiedCount: 0 };
  }
}

export default {
  onSurveyCreated,
  onSurveyUpdated,
  onMasterDataUpdated,
  createManualNotification,
  deleteRelatedNotifications,
};
