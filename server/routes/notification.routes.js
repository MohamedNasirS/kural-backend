import express from "express";
import mongoose from "mongoose";
import Notification from "../models/Notification.js";
import { connectToDatabase } from "../config/database.js";
import { isAuthenticated, hasRole } from "../middleware/auth.js";
import { writeRateLimiter } from "../middleware/rateLimit.js";
import {
  sendSuccess,
  sendCreated,
  sendBadRequest,
  sendNotFound,
  sendServerError,
  sendForbidden,
} from "../utils/responseHelpers.js";

const router = express.Router();

// Apply authentication to all routes
router.use(isAuthenticated);

// Only L0, L1, L2 can access notification admin routes
router.use(hasRole("L0", "L1", "L2"));

/**
 * Helper to get user's accessible ACs based on role
 */
function getUserAccessibleACs(user) {
  if (user.role === "L0") {
    return null; // L0 can access all
  }

  if (user.role === "L1") {
    // L1 can access their assigned ACs (could be multiple)
    if (Array.isArray(user.assignedAC)) {
      return user.assignedAC;
    }
    if (user.assignedAC) {
      return [user.assignedAC];
    }
    return [];
  }

  if (user.role === "L2") {
    // L2 can only access their single assigned AC
    if (user.assignedAC) {
      return [user.assignedAC];
    }
    return [];
  }

  return [];
}

/**
 * Check if user can access a specific AC
 */
function canUserAccessAC(user, acId) {
  if (user.role === "L0") return true;

  const accessibleACs = getUserAccessibleACs(user);
  if (!accessibleACs) return true;

  return accessibleACs.includes(acId);
}

/**
 * GET /api/admin/notifications
 * List notifications with role-based filtering and pagination
 */
router.get("/", async (req, res) => {
  try {
    await connectToDatabase();

    const { page = 1, limit = 20, scope, aci_id, type } = req.query;
    const parsedPage = Math.max(parseInt(page, 10) || 1, 1);
    const parsedLimit = Math.min(Math.max(parseInt(limit, 10) || 20, 1), 100);
    const skip = (parsedPage - 1) * parsedLimit;

    // Build query based on user role
    const query = { deleted: false };

    // Role-based filtering
    const user = req.user;
    if (user.role === "L1" || user.role === "L2") {
      const accessibleACs = getUserAccessibleACs(user);
      // Can see GLOBAL notifications + notifications for their ACs
      query.$or = [
        { scope: "GLOBAL" },
        { scope: "ACI", aci_id: { $in: accessibleACs } },
      ];
    }
    // L0 sees all notifications (no additional filter)

    // Apply optional filters
    if (scope && ["GLOBAL", "ACI"].includes(scope)) {
      query.scope = scope;
      // Remove $or if we're filtering by specific scope
      delete query.$or;

      // Re-apply role filter for ACI scope
      if (scope === "ACI" && (user.role === "L1" || user.role === "L2")) {
        const accessibleACs = getUserAccessibleACs(user);
        query.aci_id = { $in: accessibleACs };
      }
    }

    if (aci_id) {
      const parsedAcId = parseInt(aci_id, 10);
      if (!isNaN(parsedAcId)) {
        // Check if user can access this AC
        if (!canUserAccessAC(user, parsedAcId)) {
          return sendForbidden(res, "You don't have access to this AC");
        }
        query.aci_id = parsedAcId;
        query.scope = "ACI";
        delete query.$or;
      }
    }

    if (type) {
      const validTypes = [
        "SURVEY_CREATED",
        "SURVEY_UPDATED",
        "MASTER_DATA_UPDATED",
        "ANNOUNCEMENT",
        "ALERT",
        "REMINDER",
      ];
      if (validTypes.includes(type)) {
        query.type = type;
      }
    }

    // Execute query with pagination
    const [notifications, total] = await Promise.all([
      Notification.find(query)
        .sort({ createdAt: -1 })
        .skip(skip)
        .limit(parsedLimit)
        .lean(),
      Notification.countDocuments(query),
    ]);

    // Format response
    const formattedNotifications = notifications.map((n) => ({
      id: n._id.toString(),
      createdBy: n.createdBy,
      scope: n.scope,
      aci_id: n.aci_id,
      type: n.type,
      title: n.title,
      message: n.message,
      priority: n.priority,
      relatedEntity: n.relatedEntity,
      validFrom: n.validFrom,
      validTill: n.validTill,
      isAutoGenerated: n.isAutoGenerated,
      createdAt: n.createdAt,
      updatedAt: n.updatedAt,
    }));

    return sendSuccess(res, {
      notifications: formattedNotifications,
      pagination: {
        total,
        page: parsedPage,
        limit: parsedLimit,
        totalPages: Math.ceil(total / parsedLimit),
        hasMore: skip + notifications.length < total,
      },
    });
  } catch (error) {
    console.error("Error fetching notifications:", error);
    return sendServerError(res, "Failed to fetch notifications", error);
  }
});

/**
 * GET /api/admin/notifications/:id
 * Get single notification by ID
 */
router.get("/:id", async (req, res) => {
  try {
    await connectToDatabase();

    const { id } = req.params;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return sendBadRequest(res, "Invalid notification ID");
    }

    const notification = await Notification.findOne({
      _id: id,
      deleted: false,
    }).lean();

    if (!notification) {
      return sendNotFound(res, "Notification not found");
    }

    // Check access for non-L0 users
    const user = req.user;
    if (user.role !== "L0") {
      if (notification.scope === "ACI" && !canUserAccessAC(user, notification.aci_id)) {
        return sendForbidden(res, "You don't have access to this notification");
      }
    }

    return sendSuccess(res, {
      id: notification._id.toString(),
      createdBy: notification.createdBy,
      scope: notification.scope,
      aci_id: notification.aci_id,
      type: notification.type,
      title: notification.title,
      message: notification.message,
      priority: notification.priority,
      relatedEntity: notification.relatedEntity,
      validFrom: notification.validFrom,
      validTill: notification.validTill,
      isAutoGenerated: notification.isAutoGenerated,
      createdAt: notification.createdAt,
      updatedAt: notification.updatedAt,
    });
  } catch (error) {
    console.error("Error fetching notification:", error);
    return sendServerError(res, "Failed to fetch notification", error);
  }
});

/**
 * POST /api/admin/notifications
 * Create a new notification
 */
router.post("/", writeRateLimiter, async (req, res) => {
  try {
    await connectToDatabase();

    const {
      scope,
      aci_id,
      type,
      title,
      message,
      priority = "normal",
      validFrom,
      validTill,
    } = req.body;

    const user = req.user;

    // Validate required fields
    if (!scope || !["GLOBAL", "ACI"].includes(scope)) {
      return sendBadRequest(res, "scope is required and must be 'GLOBAL' or 'ACI'");
    }

    if (!type) {
      return sendBadRequest(res, "type is required");
    }

    const validTypes = ["ANNOUNCEMENT", "ALERT", "REMINDER"];
    if (!validTypes.includes(type)) {
      return sendBadRequest(res, `type must be one of: ${validTypes.join(", ")}`);
    }

    if (!title || typeof title !== "string" || title.trim().length === 0) {
      return sendBadRequest(res, "title is required");
    }

    if (title.length > 100) {
      return sendBadRequest(res, "title must be 100 characters or less");
    }

    if (!message || typeof message !== "string" || message.trim().length === 0) {
      return sendBadRequest(res, "message is required");
    }

    if (message.length > 500) {
      return sendBadRequest(res, "message must be 500 characters or less");
    }

    // Validate scope-specific rules
    if (scope === "GLOBAL") {
      // Only L0 can create GLOBAL notifications
      if (user.role !== "L0") {
        return sendForbidden(res, "Only Super Admin (L0) can create GLOBAL notifications");
      }
    }

    if (scope === "ACI") {
      if (aci_id === undefined || aci_id === null) {
        return sendBadRequest(res, "aci_id is required when scope is 'ACI'");
      }

      const parsedAcId = parseInt(aci_id, 10);
      if (isNaN(parsedAcId)) {
        return sendBadRequest(res, "aci_id must be a valid number");
      }

      // Check if user can create notification for this AC
      if (!canUserAccessAC(user, parsedAcId)) {
        return sendForbidden(res, "You don't have access to create notifications for this AC");
      }
    }

    // Validate priority
    if (priority && !["low", "normal", "high"].includes(priority)) {
      return sendBadRequest(res, "priority must be 'low', 'normal', or 'high'");
    }

    // Validate dates
    let parsedValidFrom = validFrom ? new Date(validFrom) : new Date();
    let parsedValidTill = validTill ? new Date(validTill) : null;

    if (validFrom && isNaN(parsedValidFrom.getTime())) {
      return sendBadRequest(res, "validFrom must be a valid date");
    }

    if (validTill && isNaN(parsedValidTill.getTime())) {
      return sendBadRequest(res, "validTill must be a valid date");
    }

    if (parsedValidTill && parsedValidTill < parsedValidFrom) {
      return sendBadRequest(res, "validTill must be greater than or equal to validFrom");
    }

    // Create notification
    const notification = await Notification.create({
      createdBy: {
        userId: user._id,
        role: user.role,
        name: user.name || user.email || "Admin",
      },
      scope,
      aci_id: scope === "ACI" ? parseInt(aci_id, 10) : null,
      type,
      title: title.trim(),
      message: message.trim(),
      priority,
      validFrom: parsedValidFrom,
      validTill: parsedValidTill,
      isAutoGenerated: false,
    });

    console.log(`[Notification] Admin ${user.email || user._id} created notification: ${notification.title}`);

    return sendCreated(res, {
      id: notification._id.toString(),
      createdBy: notification.createdBy,
      scope: notification.scope,
      aci_id: notification.aci_id,
      type: notification.type,
      title: notification.title,
      message: notification.message,
      priority: notification.priority,
      validFrom: notification.validFrom,
      validTill: notification.validTill,
      isAutoGenerated: notification.isAutoGenerated,
      createdAt: notification.createdAt,
    }, "Notification created successfully");
  } catch (error) {
    console.error("Error creating notification:", error);
    if (error.name === "ValidationError") {
      return sendBadRequest(res, error.message);
    }
    return sendServerError(res, "Failed to create notification", error);
  }
});

/**
 * DELETE /api/admin/notifications/:id
 * Soft delete a notification
 */
router.delete("/:id", writeRateLimiter, async (req, res) => {
  try {
    await connectToDatabase();

    const { id } = req.params;
    const user = req.user;

    if (!mongoose.Types.ObjectId.isValid(id)) {
      return sendBadRequest(res, "Invalid notification ID");
    }

    const notification = await Notification.findOne({
      _id: id,
      deleted: false,
    });

    if (!notification) {
      return sendNotFound(res, "Notification not found");
    }

    // Check delete permission based on role
    // L0: Can delete any notification
    // L1: Can delete if they created it OR if it's for their assigned ACs
    // L2: Can ONLY delete notifications they created
    if (user.role !== "L0") {
      const isCreator = notification.createdBy?.userId?.toString() === user._id.toString();

      if (user.role === "L2") {
        // L2 can ONLY delete notifications they created
        if (!isCreator) {
          return sendForbidden(res, "You can only delete notifications you created");
        }
      } else if (user.role === "L1") {
        // L1 can delete if they created it OR if it's for their assigned ACs
        const hasACAccess = notification.scope === "ACI" && canUserAccessAC(user, notification.aci_id);
        if (!isCreator && !hasACAccess) {
          return sendForbidden(res, "You don't have permission to delete this notification");
        }
      }
    }

    // Soft delete
    notification.deleted = true;
    await notification.save();

    console.log(`[Notification] Admin ${user.email || user._id} deleted notification: ${notification.title}`);

    return sendSuccess(res, { message: "Notification deleted successfully" });
  } catch (error) {
    console.error("Error deleting notification:", error);
    return sendServerError(res, "Failed to delete notification", error);
  }
});

export default router;
